name: Release

on:
  push:
    tags:
      - 'v*'

permissions:
  contents: write

jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        goos: [linux, windows, darwin]
        goarch: [amd64, arm64]
        exclude:
          # Windows ARM64 support is limited
          - goos: windows
            goarch: arm64
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Go
      uses: actions/setup-go@v5
      with:
        go-version: '1.25'
    
    - name: Get version from tag
      id: version
      run: echo "VERSION=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT
    
    - name: Build binary
      env:
        GOOS: ${{ matrix.goos }}
        GOARCH: ${{ matrix.goarch }}
        CGO_ENABLED: 0
      run: |
        # Set binary extension for Windows
        if [ "$GOOS" = "windows" ]; then
          BINARY_NAME="envm-${{ steps.version.outputs.VERSION }}-${{ matrix.goos }}-${{ matrix.goarch }}.exe"
        else
          BINARY_NAME="envm-${{ steps.version.outputs.VERSION }}-${{ matrix.goos }}-${{ matrix.goarch }}"
        fi
        
        # Build the binary
        go build -ldflags="-s -w -X main.version=${{ steps.version.outputs.VERSION }}" -o "$BINARY_NAME" .
        
        # Create archive
        if [ "$GOOS" = "windows" ]; then
          zip "${BINARY_NAME%.exe}.zip" "$BINARY_NAME"
          echo "ASSET_NAME=${BINARY_NAME%.exe}.zip" >> $GITHUB_ENV
        else
          tar -czf "${BINARY_NAME}.tar.gz" "$BINARY_NAME"
          echo "ASSET_NAME=${BINARY_NAME}.tar.gz" >> $GITHUB_ENV
        fi
    
    - name: Upload Release Asset
      uses: actions/upload-artifact@v4
      with:
        name: ${{ env.ASSET_NAME }}
        path: ${{ env.ASSET_NAME }}

  build-windows-installer:
    runs-on: windows-latest
    needs: build
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Get version from tag
      id: version
      run: echo "VERSION=$($env:GITHUB_REF -replace 'refs/tags/','')" >> $env:GITHUB_OUTPUT
      shell: powershell
    
    - name: Download Windows binary artifact
      uses: actions/download-artifact@v4
      with:
        name: envm-${{ steps.version.outputs.VERSION }}-windows-amd64.zip
        path: ./
    
    - name: Extract Windows binary
      run: |
        Expand-Archive -Path "envm-${{ steps.version.outputs.VERSION }}-windows-amd64.zip" -DestinationPath "./"
        ls
      shell: powershell
    
    - name: Setup NSIS
      run: |
        # Install NSIS using Chocolatey (most stable method)
        Write-Host "Installing NSIS using Chocolatey..."
        choco install nsis -y --no-progress --force
        
        # Verify installation
        $nsisPath = "${env:ProgramFiles(x86)}\NSIS\makensis.exe"
        if (Test-Path $nsisPath) {
          Write-Host "NSIS installed successfully: $nsisPath"
          & $nsisPath /VERSION
        } else {
          Write-Host "Standard path not found, searching for NSIS..."
          $nsisPaths = @(
            "${env:ProgramFiles}\NSIS\makensis.exe",
            "${env:ProgramFiles(x86)}\NSIS\makensis.exe",
            "${env:ChocolateyInstall}\lib\nsis\tools\makensis.exe",
            "${env:ChocolateyInstall}\bin\makensis.exe"
          )
          
          $found = $false
          foreach ($path in $nsisPaths) {
            if (Test-Path $path) {
              Write-Host "Found NSIS: $path"
              & $path /VERSION
              $found = $true
              break
            }
          }
          
          if (-not $found) {
            throw "NSIS installation failed, not found in any expected location"
          }
        }
      shell: powershell
    
    - name: Update NSIS script and prepare binary
      run: |
        $version = "${{ steps.version.outputs.VERSION }}" -replace '^v',''
        Write-Host "Processing version: $version"
        
        # Find the actual binary file
        $binaryFile = Get-ChildItem -Name "envm-${{ steps.version.outputs.VERSION }}-windows-amd64.exe"
        if (-not $binaryFile) {
          Write-Host "Binary file not found, listing current files:"
          Get-ChildItem
          throw "Expected binary file not found"
        }
        
        Write-Host "Found binary file: $binaryFile"
        
        # Update NSIS script
        $content = Get-Content "envm-installer.nsi" -Raw
        $content = $content -replace '!define PRODUCT_VERSION "1.0.0"', "!define PRODUCT_VERSION `"$version`""
        $content = $content -replace 'OutFile "envm-installer-1.0.0.exe"', "OutFile `"envm-installer-$version.exe`""
        # Update file reference using actual filename  
        $content = $content -replace 'File /oname=envm.exe "envm-\$\{PRODUCT_VERSION\}-windows-amd64.exe"', "File /oname=envm.exe `"$binaryFile`""
        Set-Content "envm-installer.nsi" -Value $content
        
        Write-Host "NSIS script updated for version: $version"
        Write-Host "Binary file reference: $binaryFile"
      shell: powershell
    
    - name: Build installer
      run: |
        # Find and use makensis
        $nsisPaths = @(
          "${env:ProgramFiles(x86)}\NSIS\makensis.exe",
          "${env:ProgramFiles}\NSIS\makensis.exe",
          "${env:ChocolateyInstall}\lib\nsis\tools\makensis.exe",
          "${env:ChocolateyInstall}\bin\makensis.exe"
        )
        
        $makensisPath = $null
        foreach ($path in $nsisPaths) {
          if (Test-Path $path) {
            $makensisPath = $path
            Write-Host "Using NSIS: $path"
            break
          }
        }
        
        if (-not $makensisPath) {
          throw "makensis.exe not found"
        }
        
        # Verify NSIS version
        & $makensisPath /VERSION
        
        # Build installer
        Write-Host "Building installer..."
        & $makensisPath envm-installer.nsi
        
        # Verify generated files
        Get-ChildItem *.exe | ForEach-Object { 
          Write-Host "Generated: $($_.Name) ($($_.Length) bytes)"
        }
      shell: powershell
    
    - name: Upload installer artifact
      uses: actions/upload-artifact@v4
      with:
        name: envm-installer-${{ steps.version.outputs.VERSION }}.exe
        path: envm-installer-*.exe

  generate-release-notes:
    runs-on: ubuntu-latest
    outputs:
      release-notes: ${{ steps.notes.outputs.notes }}
    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0
    
    - name: Get version from tag
      id: version
      run: echo "VERSION=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT
    
    - name: Generate release notes
      id: notes
      run: |
        CURRENT_TAG="${{ steps.version.outputs.VERSION }}"
        PREVIOUS_TAG=$(git describe --tags --abbrev=0 $CURRENT_TAG^ 2>/dev/null || echo "")
        if [ -z "$PREVIOUS_TAG" ]; then
          PREVIOUS_TAG=$(git rev-list --max-parents=0 HEAD)
        fi
        
        # åˆ›å»ºå‘å¸ƒè¯´æ˜
        cat > release-notes.md << 'EOF'
        # ğŸ‰ envm ${{ steps.version.outputs.VERSION }} å‘å¸ƒ
        
        æ„Ÿè°¢æ‰€æœ‰è´¡çŒ®è€…å¯¹ envm é¡¹ç›®çš„æ”¯æŒï¼è¿™ä¸ªç‰ˆæœ¬åŒ…å«äº†è®¸å¤šæ”¹è¿›å’Œæ–°åŠŸèƒ½ã€‚
        
        ## ğŸ“¦ å®‰è£…æ–¹æ³•
        
        ### Windows ç”¨æˆ·
        
        #### ğŸ¯ æ–¹å¼1ï¼šEXEå®‰è£…ç¨‹åºï¼ˆæ¨èï¼‰
        1. ä¸‹è½½ `envm-installer-${{ steps.version.outputs.VERSION }}.exe`
        2. åŒå‡»è¿è¡Œå®‰è£…ç¨‹åºï¼ˆæ— éœ€ç®¡ç†å‘˜æƒé™ï¼‰
        3. é€‰æ‹©å®‰è£…è·¯å¾„å’Œç»„ä»¶
        4. å®Œæˆå®‰è£…ï¼ˆè‡ªåŠ¨é…ç½®ç¯å¢ƒå˜é‡ï¼‰
        
        **å®‰è£…ç¨‹åºç‰¹æ€§ï¼š**
        - ğŸ¯ è‡ªå®šä¹‰å®‰è£…è·¯å¾„
        - âš™ï¸ å¯é€‰ç»„ä»¶å®‰è£…
        - ğŸ›¡ï¸ æ™ºèƒ½è·¯å¾„éªŒè¯
        - ğŸ”„ æ”¯æŒç‰ˆæœ¬å‡çº§
        
        #### ğŸ’¾ æ–¹å¼2ï¼šä¾¿æºç‰ˆ
        1. ä¸‹è½½ `envm-${{ steps.version.outputs.VERSION }}-windows-amd64.zip`
        2. è§£å‹åˆ°ä»»æ„ç›®å½•
        3. æ‰‹åŠ¨æ·»åŠ åˆ°ç³»ç»Ÿ PATH
        
        #### ğŸš€ æ–¹å¼3ï¼šä¸€é”®å®‰è£…è„šæœ¬
        ```powershell
        Invoke-Expression (Invoke-WebRequest -Uri "https://raw.githubusercontent.com/FirewineXie/envm/main/install.ps1" -UseBasicParsing).Content
        ```
        
        ### Linux/macOS ç”¨æˆ·
        
        #### ğŸš€ ä¸€é”®å®‰è£…
        ```bash
        curl -fsSL https://raw.githubusercontent.com/FirewineXie/envm/main/install.sh | bash
        ```
        
        #### ğŸ“¦ æ‰‹åŠ¨å®‰è£…
        ```bash
        # Linux AMD64
        wget https://github.com/FirewineXie/envm/releases/download/${{ steps.version.outputs.VERSION }}/envm-${{ steps.version.outputs.VERSION }}-linux-amd64.tar.gz
        tar -xzf envm-${{ steps.version.outputs.VERSION }}-linux-amd64.tar.gz
        sudo mv envm-${{ steps.version.outputs.VERSION }}-linux-amd64 /usr/local/bin/envm
        chmod +x /usr/local/bin/envm
        
        # macOS AMD64
        wget https://github.com/FirewineXie/envm/releases/download/${{ steps.version.outputs.VERSION }}/envm-${{ steps.version.outputs.VERSION }}-darwin-amd64.tar.gz
        # ... ç±»ä¼¼æ“ä½œ
        ```
        
        ## âœ¨ ä¸»è¦ç‰¹æ€§
        
        - ğŸ¯ **å¤šå¹³å°æ”¯æŒ**: Windows, Linux, macOS
        - ğŸ”§ **æ™ºèƒ½ç‰ˆæœ¬ç®¡ç†**: è‡ªåŠ¨ä¸‹è½½å’Œåˆ‡æ¢ Go ç‰ˆæœ¬
        - âš¡ **å¿«é€Ÿåˆ‡æ¢**: ç±»ä¼¼ nvm çš„ä½¿ç”¨ä½“éªŒ
        - ğŸ›¡ï¸ **å®‰å…¨å¯é **: è‡ªåŠ¨éªŒè¯ä¸‹è½½æ–‡ä»¶å®Œæ•´æ€§
        - ğŸ“ **çµæ´»é…ç½®**: æ”¯æŒè‡ªå®šä¹‰ä¸‹è½½æºå’Œå®‰è£…è·¯å¾„
        
        EOF
        
        # ç”Ÿæˆå˜æ›´æ—¥å¿—
        echo "" >> release-notes.md
        echo "## ğŸ“ æœ¬æ¬¡æ›´æ–°å†…å®¹" >> release-notes.md
        echo "" >> release-notes.md
        
        # è·å–æ–°åŠŸèƒ½
        echo "### ğŸš€ æ–°åŠŸèƒ½" >> release-notes.md
        NEW_FEATURES=$(git log $PREVIOUS_TAG..$CURRENT_TAG --oneline --grep="feat:" --grep="feature:" --grep="æ–°å¢" --grep="æ·»åŠ " --grep="âœ¨")
        if [ ! -z "$NEW_FEATURES" ]; then
          echo "$NEW_FEATURES" | sed 's/^/- /' >> release-notes.md
        else
          echo "- æ— æ–°åŠŸèƒ½æ·»åŠ " >> release-notes.md
        fi
        echo "" >> release-notes.md
        
        # è·å–é”™è¯¯ä¿®å¤
        echo "### ğŸ› é”™è¯¯ä¿®å¤" >> release-notes.md
        BUG_FIXES=$(git log $PREVIOUS_TAG..$CURRENT_TAG --oneline --grep="fix:" --grep="ä¿®å¤" --grep="bugfix" --grep="ğŸ›")
        if [ ! -z "$BUG_FIXES" ]; then
          echo "$BUG_FIXES" | sed 's/^/- /' >> release-notes.md
        else
          echo "- æ— é”™è¯¯ä¿®å¤" >> release-notes.md
        fi
        echo "" >> release-notes.md
        
        # è·å–æ”¹è¿›ä¼˜åŒ–
        echo "### âœ¨ æ”¹è¿›ä¼˜åŒ–" >> release-notes.md
        IMPROVEMENTS=$(git log $PREVIOUS_TAG..$CURRENT_TAG --oneline --grep="improve:" --grep="refactor:" --grep="ä¼˜åŒ–" --grep="æ”¹è¿›" --grep="é‡æ„" --grep="â™»ï¸" --grep="âš¡")
        if [ ! -z "$IMPROVEMENTS" ]; then
          echo "$IMPROVEMENTS" | sed 's/^/- /' >> release-notes.md
        else
          echo "- æ— æ”¹è¿›ä¼˜åŒ–" >> release-notes.md
        fi
        echo "" >> release-notes.md
        
        # ç›¸å…³ Issues å’Œ PRs
        echo "## ğŸ”— ç›¸å…³é—®é¢˜å’Œæ‹‰å–è¯·æ±‚" >> release-notes.md
        echo "" >> release-notes.md
        ISSUES=$(git log $PREVIOUS_TAG..$CURRENT_TAG --oneline | grep -oE "#[0-9]+" | sort -u | head -10)
        if [ ! -z "$ISSUES" ]; then
          for issue in $ISSUES; do
            echo "- å…³è”é—®é¢˜/PR: $issue" >> release-notes.md
          done
        else
          echo "- æ— ç›´æ¥å…³è”çš„ Issues æˆ– PRs" >> release-notes.md
        fi
        echo "" >> release-notes.md
        
        # ç‰ˆæœ¬ç»Ÿè®¡
        echo "## ğŸ“Š ç‰ˆæœ¬ç»Ÿè®¡" >> release-notes.md
        echo "" >> release-notes.md
        COMMIT_COUNT=$(git rev-list --count $PREVIOUS_TAG..$CURRENT_TAG)
        echo "- ğŸ“ **æäº¤æ•°é‡**: $COMMIT_COUNT" >> release-notes.md
        echo "- ğŸ“… **å‘å¸ƒæ—¶é—´**: $(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> release-notes.md
        echo "" >> release-notes.md
        
        # å¿«é€Ÿå¼€å§‹
        echo "## ğŸš€ å¿«é€Ÿå¼€å§‹" >> release-notes.md
        echo "" >> release-notes.md
        echo "```bash" >> release-notes.md
        echo "# æŸ¥çœ‹å¯ç”¨ç‰ˆæœ¬" >> release-notes.md
        echo "envm list" >> release-notes.md
        echo "" >> release-notes.md
        echo "# å®‰è£… Go 1.21" >> release-notes.md
        echo "envm install 1.21" >> release-notes.md
        echo "" >> release-notes.md
        echo "# åˆ‡æ¢åˆ° Go 1.21" >> release-notes.md
        echo "envm use 1.21" >> release-notes.md
        echo "```" >> release-notes.md
        echo "" >> release-notes.md
        
        # è·å–å¸®åŠ©
        echo "## ğŸ’¡ è·å–å¸®åŠ©" >> release-notes.md
        echo "" >> release-notes.md
        echo "- ğŸ“– **ä½¿ç”¨æ–‡æ¡£**: [README.md](https://github.com/FirewineXie/envm#readme)" >> release-notes.md
        echo "- ğŸ› **æŠ¥å‘Šé—®é¢˜**: [æäº¤ Issue](https://github.com/FirewineXie/envm/issues/new)" >> release-notes.md
        echo "- â­ **æ”¯æŒé¡¹ç›®**: [ç»™é¡¹ç›®ç‚¹ä¸ªæ˜Ÿæ ‡](https://github.com/FirewineXie/envm)" >> release-notes.md
        
        echo "---" >> release-notes.md
        echo "ğŸ¤– *æ­¤å‘å¸ƒè¯´æ˜ç”± GitHub Actions è‡ªåŠ¨ç”Ÿæˆ*" >> release-notes.md
        
        # è¾“å‡ºåˆ° GitHub Actions
        {
          echo 'notes<<EOF'
          cat release-notes.md
          echo EOF
        } >> $GITHUB_OUTPUT

  release:
    needs: [build, build-windows-installer, generate-release-notes]
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    
    - name: Get version from tag
      id: version
      run: echo "VERSION=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT
    
    - name: Download all artifacts
      uses: actions/download-artifact@v4
      with:
        path: ./artifacts
    
    - name: Create Release
      uses: softprops/action-gh-release@v1
      with:
        tag_name: ${{ steps.version.outputs.VERSION }}
        name: "ğŸš€ envm ${{ steps.version.outputs.VERSION }} æ­£å¼å‘å¸ƒ"
        body: ${{ needs.generate-release-notes.outputs.release-notes }}
        files: ./artifacts/**/*
        draft: false
        prerelease: false
        make_latest: true
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}